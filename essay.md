# Сравнение Ada и POSIX механизмов (Маклаков Артём Б05-332)

В Ada параллельные единицы — это задачи (tasks), являющиеся частью языка. Для прямой синхронной связи между задачами язык предоставляет рандеву (rendezvous): вызывающая задача делает вызов входа (entry), а обслуживающая выполняет accept-блок. Во время рандеву обе стороны могут обмениваться параметрами в обе стороны (в том числе и исключениями), а код внутри accept может быть сколь угодно сложным.

В POSIX же, параллельные единицы — это потоки (pthread). Их создание и завершение определено библиотечными вызовами (pthread_create, pthread_join), а не синтаксисом языка. POSIX не предоставляет прямого эквивалента рандеву как языкового примитива: синхронный вызов и ответ обычно строят поверх сокетов/каналов/канальных пар или через примитивы синхронизации (мьютекс+условная переменная). 

Ada имеет оператор select, который ожидает одно из событий. Поток приостанавливается пока не выполнится хотя бы одно из ожидаемых событий, затем исполнение продолжается. В Ada select работает над задачными входами и временем, напрямую моделируя многовариантное ожидание взаимодействий задачи с другими задачами.

В POSIX select() мультиплексирует файловые дескрипторы — то есть это механизм ввода/вывода, а не синхронизации потоков. То есть больше относится к сокетам либо файлам, в то время как select Ada — больше подразумевает задачи или взаимодействия. Для схожих шаблонов в POSIX обычно комбинируют блокирующие очереди и условные переменные с тайм-аутами.

Ada предоставляет protected objects — пассивные ресурсы с языковыми гарантиями взаимного исключения и условной синхронизации. В POSIX ту же роль играют мьютексы и условные переменные. Можно сказать, что Ada вшивает безопасные паттерны (монитор, барьеры, потолок) прямо в типы и операторы. В то время как в POSIX безопасная семантика достигается соглашениями об использовании примитивов и правильной настройкой атрибутов.

Ada поддерживает несколько политик планирования: помимо базовой preemptive fixed priority (FIFO within priorities) доступны non-preemptive, round-robin и EDF (earliest-deadline-first), также задаются политики очередей входов (FIFO/по приоритетам). Это — язык+рантайм-уровень с прагмами конфигурации.
В POSIX набор стандартных политик — SCHED_FIFO, SCHED_RR, SCHED_OTHER управляются через sched_setscheduler и параметры приоритета в sched_param. 

Обе экосистемы имеют FIFO/RR и потолочные/наследуемые протоколы для защиты ресурсов. Однако, Ada добавляет EDF и сквозную языковую модель очередей входов/барьеров. В POSIX многое это просто действия операционной системы и библиотеки, а не языковая конструкция.

Ada содержит Asynchronous Transfer of Control (ATC) — форму select … then abort … end select, позволяющую быстро прервать выполняемую часть кода по срабатыванию триггера (входной вызов или истечение задержки). При этом, секции с защитой от прерывания не обрываются посередине, между триггером и прерыванием возможны гонки, accept внутри «abortable part» запрещён.
В POSIX роль асинхронного вмешательства обычно играют сигналы и отмена потоков pthread_cancel. По умолчанию отмена отложенная и срабатывает в точках отмены. Асинхронная отмена допускается, но считается опасной так как нельзя гарантировать корректное освобождение ресурсов. Сигналы — механизм оповещения, требующий аккуратности и минимально безопасного обработчика. 
 
Подводя итоги, Ada предлагает языковую модель конкурентности и реального времени: рандеву, select, защищённые объекты, ATC, политики и очереди. POSIX даёт фундаментальные системные примитивы (потоки, мьютексы, select(), сигналы), из которых можно собрать аналогичные объекты, но цена — больший объём кода и ответственность за корректное использование. В задачах с жёсткими временными требованиями и доказуемостью поведения преимущества Ada особенно заметны. В задачах системного уровня и сетевого I/O POSIX остаётся универсальной и широко поддерживаемой основой.